top_grobs <- gridExtra::arrangeGrob(
grobs = top_grobs[2], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line") )
}
list2env(top_grobs, env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ):L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line")
)
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line")
)
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(dirIN, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ifelse(!dir.exists(file.path(dirOUT)),
dir.create(file.path(dirOUT)), FALSE)
#  ml <- gridExtra::marrangeGrob(grobs = g2p,
#                                layout_matrix = layout, top = "")
#  pdf(file = file.path(dirOUT, fname), paper = 'a4')
#  print(ml)
#  invisible(dev.off())
return(layout)
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(dirOUT, fname)))
}
nets2Page <- function(directory, col_var, row_var, fname, sep_char, mainT, Tlegend_fname){
if(missing(directory)) {directory <- 'NetworkGraphs/Intermediates'}
dirIN <- file.path(directory); dirOUT <- file.path(directory, 'Output')
if(missing(fname)) {fname <- 'mosaiced_Nets.pdf'}
if(missing(sep_char))  {sep_char <- ''}
if(missing(mainT))  {mainT <- ''}
if(missing(Tlegend_fname)) {Tlegend_fname <- 'TableLegend.png'}
rowOrder <- matrix( # this sets up a matrix to have rows groups in order
data = rep(row_var, each = length(col_var)),
ncol = length(col_var), byrow = T)
colOrder <- matrix( # this sets up a matrix to have column groups in order
data = rep(col_var, each = length(col_var)),
ncol = length(col_var), byrow = F)
image_orders <- matrix(paste0(colOrder, sep_char, rowOrder, '.png'),
ncol = length(col_var))
image_orders <- as.vector(t(image_orders))
image_orders <- file.path(dirIN, image_orders)
images = lapply(image_orders, png::readPNG)
grob_images = lapply(images, grid::rasterGrob)
nPlots <- (length(col_var) * length(row_var))
colN <- length(col_var)
rowN <- nPlots / length(col_var)
# define the layout
layout <- matrix(nrow = rowN, ncol = colN, byrow = T,
data = c(rep(1:(rowN -1), each = colN),
rowN:((rowN-1) + colN) ) )
layout <- rbind(layout, rep((max(layout) + 1), ncol(layout)))
# Recover the top grobs!!
top_grobs <- split(grob_images[1:(length(grob_images) - rowN)],
ceiling(seq_along(grob_images[1:(length(grob_images) -
rowN)]) / rowN))
names(top_grobs) <- paste0('t', seq(1:length(top_grobs)))
# title up the real top grob
t1 <- gridExtra::arrangeGrob(grobs = top_grobs$t1, ncol = colN,
padding = unit(0.0, "line"),
left = row_var[1], top = grid::textGrob(mainT, vjust = -1.1))
# this will get all of the subsequent top grobs !!!!!!!!
if(rowN >= 3){
top_grobs <- mapply(gridExtra::arrangeGrob,
grobs = top_grobs[2:length(top_grobs)], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line"))
} else {
top_grobs <- gridExtra::arrangeGrob(
grobs = top_grobs[2], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line") )
}
list2env(top_grobs, env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ):L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line")
)
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line")
)
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(dirIN, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ifelse(!dir.exists(file.path(dirOUT)),
dir.create(file.path(dirOUT)), FALSE)
ml <- gridExtra::marrangeGrob(grobs = g2p,
layout_matrix = layout, top = "")
pdf(file = file.path(dirOUT, fname), paper = 'a4')
print(ml)
invisible(dev.off())
# return(layout)
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(dirOUT, fname)))
}
nets2Page(col_var = c('Molecular', 'Observations'), fname = 'Mosaiced_MolObs_net',
directory = 'NetworkGraphs/Intermediates-Paper',
mainT = 'Comparision of Foraging Patterns from Molecular and Observations',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
nets2Page <- function(directory, col_var, row_var, fname, sep_char, mainT, Tlegend_fname){
if(missing(directory)) {directory <- 'NetworkGraphs/Intermediates'}
dirIN <- file.path(directory); dirOUT <- file.path(directory, 'Output')
if(missing(fname)) {fname <- 'mosaiced_Nets.pdf'}
if(missing(sep_char))  {sep_char <- ''}
if(missing(mainT))  {mainT <- ''}
if(missing(Tlegend_fname)) {Tlegend_fname <- 'TableLegend.png'}
rowOrder <- matrix( # this sets up a matrix to have rows groups in order
data = rep(row_var, each = length(col_var)),
ncol = length(col_var), byrow = T)
colOrder <- matrix( # this sets up a matrix to have column groups in order
data = rep(col_var, each = length(col_var)),
ncol = length(col_var), byrow = F)
image_orders <- matrix(paste0(colOrder, sep_char, rowOrder, '.png'),
ncol = length(col_var))
image_orders <- as.vector(t(image_orders))
image_orders <- file.path(dirIN, image_orders)
images = lapply(image_orders, png::readPNG)
grob_images = lapply(images, grid::rasterGrob)
nPlots <- (length(col_var) * length(row_var))
colN <- length(col_var)
rowN <- nPlots / length(col_var)
# define the layout
layout <- matrix(nrow = rowN, ncol = colN, byrow = T,
data = c(rep(1:(rowN -1), each = colN),
rowN:((rowN-1) + colN) ) )
layout <- rbind(layout, rep((max(layout) + 1), ncol(layout)))
# Recover the top grobs!!
top_grobs <- split(grob_images[1:(length(grob_images) - rowN)],
ceiling(seq_along(grob_images[1:(length(grob_images) -
rowN)]) / rowN))
names(top_grobs) <- paste0('t', seq(1:length(top_grobs)))
# title up the real top grob
t1 <- gridExtra::arrangeGrob(grobs = top_grobs$t1, ncol = colN,
padding = unit(0.0, "line"),
left = row_var[1], top = grid::textGrob(mainT, vjust = -1.1))
# this will get all of the subsequent top grobs !!!!!!!!
if(length(top_grobs) >= 3){
top_grobs <- mapply(gridExtra::arrangeGrob,
grobs = top_grobs[2:length(top_grobs)], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line"))
} else {
top_grobs <- gridExtra::arrangeGrob(
grobs = top_grobs[2], ncol = colN,
left = row_var[2],
padding = unit(0.0, "line") )
}
list2env(top_grobs, env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ):L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line")
)
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line")
)
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(dirIN, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ifelse(!dir.exists(file.path(dirOUT)),
dir.create(file.path(dirOUT)), FALSE)
#  ml <- gridExtra::marrangeGrob(grobs = g2p,
#                                layout_matrix = layout, top = "")
#  pdf(file = file.path(dirOUT, fname), paper = 'a4')
#  print(ml)
#  invisible(dev.off())
return(layout)
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(dirOUT, fname)))
}
nets2Page(col_var = c('Molecular', 'Observations'), fname = 'Mosaiced_MolObs_net',
directory = 'NetworkGraphs/Intermediates-Paper',
mainT = 'Comparision of Foraging Patterns from Molecular and Observations',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
gridExtra::marrangeGrob(grobs = b, nrow = 3, ncol = 2,  top = "")
nets2Page <- function(directory, col_var, row_var, fname, sep_char, mainT, Tlegend_fname){
if(missing(directory)) {directory <- 'NetworkGraphs/Intermediates'}
dirIN <- file.path(directory); dirOUT <- file.path(directory, 'Output')
if(missing(fname)) {fname <- 'mosaiced_Nets.pdf'}
if(missing(sep_char))  {sep_char <- ''}
if(missing(mainT))  {mainT <- ''}
if(missing(Tlegend_fname)) {Tlegend_fname <- 'TableLegend.png'}
rowOrder <- matrix( # this sets up a matrix to have rows groups in order
data = rep(row_var, each = length(col_var)),
ncol = length(col_var), byrow = T)
colOrder <- matrix( # this sets up a matrix to have column groups in order
data = rep(col_var, each = length(col_var)),
ncol = length(col_var), byrow = F)
image_orders <- matrix(paste0(colOrder, sep_char, rowOrder, '.png'),
ncol = length(col_var))
image_orders <- as.vector(t(image_orders))
image_orders <- file.path(dirIN, image_orders)
images = lapply(image_orders, png::readPNG)
grob_images = lapply(images, grid::rasterGrob)
nPlots <- (length(col_var) * length(row_var))
colN <- length(col_var)
rowN <- nPlots / length(col_var)
# define the layout
layout <- matrix(nrow = rowN, ncol = colN, byrow = T,
data = c(rep(1:(rowN -1), each = colN),
rowN:((rowN-1) + colN) ) )
layout <- rbind(layout, rep((max(layout) + 1), ncol(layout)))
# Recover the top grobs!!
top_grobs <- split(grob_images[1:(length(grob_images) - rowN)],
ceiling(seq_along(grob_images[1:(length(grob_images) -
rowN)]) / rowN))
names(top_grobs) <- paste0('t', seq(1:length(top_grobs)))
# title up the real top grob
t1 <- gridExtra::arrangeGrob(grobs = top_grobs$t1, ncol = colN,
padding = unit(0.0, "line"),
left = row_var[1], top = grid::textGrob(mainT, vjust = -1.1))
# this will get all of the subsequent top grobs !!!!!!!!
if(length(top_grobs) >= 3){
top_grobs <- mapply(gridExtra::arrangeGrob,
grobs = top_grobs[2:length(top_grobs)], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line"))
} else {
top_grobs <- gridExtra::arrangeGrob(
grobs = top_grobs[2], ncol = colN,
left = row_var[2],
padding = unit(0.0, "line") )
}
list2env(top_grobs, env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ):L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line")
)
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line")
)
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(dirIN, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ifelse(!dir.exists(file.path(dirOUT)),
dir.create(file.path(dirOUT)), FALSE)
return(g2p)
#  ml <- gridExtra::marrangeGrob(grobs = g2p,
#                                layout_matrix = layout, top = "")
#  pdf(file = file.path(dirOUT, fname), paper = 'a4')
#  print(ml)
#  invisible(dev.off())
return(layout)
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(dirOUT, fname)))
}
b <- nets2Page(col_var = c('Molecular', 'Observations'), fname = 'Mosaiced_MolObs_net',
directory = 'NetworkGraphs/Intermediates-Paper',
mainT = 'Comparision of Foraging Patterns from Molecular and Observations',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
gridExtra::marrangeGrob(grobs = b, nrow = 3, ncol = 2,  top = "")
gridExtra::marrangeGrob(grobs = b, nrow = 3, ncol = 1,  top = "")
gridExtra::marrangeGrob(grobs = b, nrow = 4, ncol = 1,  top = "")
gridExtra::marrangeGrob(grobs = b, nrow = 4, ncol = 1,  top = "")
nets2Page <- function(directory, col_var, row_var, fname, sep_char, mainT, Tlegend_fname){
if(missing(directory)) {directory <- 'NetworkGraphs/Intermediates'}
dirIN <- file.path(directory); dirOUT <- file.path(directory, 'Output')
if(missing(fname)) {fname <- 'mosaiced_Nets.pdf'}
if(missing(sep_char))  {sep_char <- ''}
if(missing(mainT))  {mainT <- ''}
if(missing(Tlegend_fname)) {Tlegend_fname <- 'TableLegend.png'}
rowOrder <- matrix( # this sets up a matrix to have rows groups in order
data = rep(row_var, each = length(col_var)),
ncol = length(col_var), byrow = T)
colOrder <- matrix( # this sets up a matrix to have column groups in order
data = rep(col_var, each = length(col_var)),
ncol = length(col_var), byrow = F)
image_orders <- matrix(paste0(colOrder, sep_char, rowOrder, '.png'),
ncol = length(col_var))
image_orders <- as.vector(t(image_orders))
image_orders <- file.path(dirIN, image_orders)
images = lapply(image_orders, png::readPNG)
grob_images = lapply(images, grid::rasterGrob)
nPlots <- (length(col_var) * length(row_var))
colN <- length(col_var)
rowN <- nPlots / length(col_var)
# define the layout
layout <- matrix(nrow = rowN, ncol = colN, byrow = T,
data = c(rep(1:(rowN -1), each = colN),
rowN:((rowN-1) + colN) ) )
layout <- rbind(layout, rep((max(layout) + 1), ncol(layout)))
# Recover the top grobs!!
top_grobs <- split(grob_images[1:(length(grob_images) - rowN)],
ceiling(seq_along(grob_images[1:(length(grob_images) -
rowN)]) / rowN))
names(top_grobs) <- paste0('t', seq(1:length(top_grobs)))
# title up the real top grob
t1 <- gridExtra::arrangeGrob(grobs = top_grobs$t1, ncol = colN,
padding = unit(0.0, "line"),
left = row_var[1], top = grid::textGrob(mainT, vjust = -1.1))
# this will get all of the subsequent top grobs !!!!!!!!
if(length(top_grobs) >= 3){
top_grobs <- mapply(gridExtra::arrangeGrob,
grobs = top_grobs[2:length(top_grobs)], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line"))
} else {
top_grobs <- gridExtra::arrangeGrob(
grobs = top_grobs[2], ncol = colN,
left = row_var[2],
padding = unit(0.0, "line") )
}
list2env(top_grobs, env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ):L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line")
)
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line")
)
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(dirIN, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ifelse(!dir.exists(file.path(dirOUT)),
dir.create(file.path(dirOUT)), FALSE)
#  return(g2p)
#  ml <- gridExtra::marrangeGrob(grobs = g2p,
#                                layout_matrix = layout, top = "")
#  pdf(file = file.path(dirOUT, fname), paper = 'a4')
#  print(ml)
#  invisible(dev.off())
return(t1)
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(dirOUT, fname)))
}
b <- nets2Page(col_var = c('Molecular', 'Observations'), fname = 'Mosaiced_MolObs_net',
directory = 'NetworkGraphs/Intermediates-Paper',
mainT = 'Comparision of Foraging Patterns from Molecular and Observations',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
gridExtra::marrangeGrob(grobs = b, nrow = 4, ncol = 1,  top = "")
plot_grid(b)
grid::plot_grid(b)
cowplot::plot_grid(b)
nets2Page <- function(directory, col_var, row_var, fname, sep_char, mainT, Tlegend_fname){
if(missing(directory)) {directory <- 'NetworkGraphs/Intermediates'}
dirIN <- file.path(directory); dirOUT <- file.path(directory, 'Output')
if(missing(fname)) {fname <- 'mosaiced_Nets.pdf'}
if(missing(sep_char))  {sep_char <- ''}
if(missing(mainT))  {mainT <- ''}
if(missing(Tlegend_fname)) {Tlegend_fname <- 'TableLegend.png'}
rowOrder <- matrix( # this sets up a matrix to have rows groups in order
data = rep(row_var, each = length(col_var)),
ncol = length(col_var), byrow = T)
colOrder <- matrix( # this sets up a matrix to have column groups in order
data = rep(col_var, each = length(col_var)),
ncol = length(col_var), byrow = F)
image_orders <- matrix(paste0(colOrder, sep_char, rowOrder, '.png'),
ncol = length(col_var))
image_orders <- as.vector(t(image_orders))
image_orders <- file.path(dirIN, image_orders)
images = lapply(image_orders, png::readPNG)
grob_images = lapply(images, grid::rasterGrob)
nPlots <- (length(col_var) * length(row_var))
colN <- length(col_var)
rowN <- nPlots / length(col_var)
# define the layout
layout <- matrix(nrow = rowN, ncol = colN, byrow = T,
data = c(rep(1:(rowN -1), each = colN),
rowN:((rowN-1) + colN) ) )
layout <- rbind(layout, rep((max(layout) + 1), ncol(layout)))
# Recover the top grobs!!
top_grobs <- split(grob_images[1:(length(grob_images) - rowN)],
ceiling(seq_along(grob_images[1:(length(grob_images) -
rowN)]) / rowN))
names(top_grobs) <- paste0('t', seq(1:length(top_grobs)))
# title up the real top grob
t1 <- gridExtra::arrangeGrob(grobs = top_grobs$t1, ncol = colN,
padding = unit(0.0, "line"),
left = row_var[1], top = grid::textGrob(mainT, vjust = -1.1))
# this will get all of the subsequent top grobs !!!!!!!!
if(length(top_grobs) >= 3){
top_grobs <- mapply(gridExtra::arrangeGrob,
grobs = top_grobs[2:length(top_grobs)], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line"))
} else {
top_grobs <- gridExtra::arrangeGrob(
grobs = top_grobs[2], ncol = colN,
left = row_var[2],
padding = unit(0.0, "line") )
}
list2env(top_grobs, env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ):L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line")
)
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line")
)
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(dirIN, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ifelse(!dir.exists(file.path(dirOUT)),
dir.create(file.path(dirOUT)), FALSE)
#  return(g2p)
#  ml <- gridExtra::marrangeGrob(grobs = g2p,
#                                layout_matrix = layout, top = "")
#  pdf(file = file.path(dirOUT, fname), paper = 'a4')
#  print(ml)
#  invisible(dev.off())
return(top_grobs)
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(dirOUT, fname)))
}
b <- nets2Page(col_var = c('Molecular', 'Observations'), fname = 'Mosaiced_MolObs_net',
directory = 'NetworkGraphs/Intermediates-Paper',
mainT = 'Comparision of Foraging Patterns from Molecular and Observations',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
cowplot::plot_grid(b)
