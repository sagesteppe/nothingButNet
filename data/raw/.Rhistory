padding = unit(0.0, "line"))
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line"))
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(directory, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ml <- gridExtra::marrangeGrob(grobs = g2p,
layout_matrix = layout, top = '')
pdf(file = file.path(directory, fname), paper = 'a4')
print(ml)
invisible(dev.off())
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(directory, fname)))
return(g2p)
}
tableLegend2(x = resin, node_clrs = c("#CEAB07", "deeppink2"), ntwrks_page = 9,
colN = 3, LcolN = 1, legend_items = c("Bombus", "Plant"),
table_items = arranged_plants, fill_col = 'black',
LegcolN = 8, y.space = c(1, 1.35, 1.25, 2.25, 1.95))
legend <- netPage2(col_var = c('Kraken', 'Bracken', 'BLAST'),
mainT = 'Comparision of Foraging Patterns from Three Sequence Alignment Algorithms',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
#' @param y.space a numeric vector of 'distances' for the legend elements
#' @param filename defaults to 'SizeLegend'
#' @param ntwrks_page the number of networks you plan on placing on each page
#' @param LcolN number of columns to split legend across
#' @param LegcolN number of columns in the table
#' @param colN number of columns for the nets on the page
#' @seealso
#' @example category_legend_drawer(node_clrs
#' = c("#CEAB07", "deeppink2"), LcolN = 1,
#'  legend_items = c("Bombus", "Plant"), ntwrks_page = 9, colN =3)
tableLegend2 <- function(x, table_items, directory, fname, legend_items, node_clrs,
fill_col, y.space, ntwrks_page, colN, LcolN, LegcolN){
if(missing(directory)) { directory <- 'NetworkGraphs' }
if(missing(fname)) {fname <- 'TableLegend.png'}
if(missing(fill_col)){fill_col <- 'white'}
if(missing(y.space)){y.space <- seq(from = 1, to = 2, length.out = 5)}
dims <- graph_dims(ntwrks_page, col = colN)
# create the categorical legend.
d <- data.frame(Group = c('Bombus', 'Plant'),
Dummy = c(1,1), Dummy2 = c(1,1))
v <- c("#CEAB07", "deeppink2")
names(v) <- c('Bombus', 'Plant')
p <- ggplot2::ggplot(d, ggplot2::aes(x= Dummy, y=Dummy2, color = Group)) +
ggplot2::geom_point() +
ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size=12))) +
ggplot2::scale_fill_manual(v) +
ggplot2::labs(color = 'Major Interacting\nGroups ') +
ggplot2::theme(legend.key = ggplot2::element_rect(fill = "white"),
legend.title.align = 0.5,
legend.key.size = unit(2.5, 'cm'),
legend.key.height = unit(3, 'cm'),
legend.key.width = unit(3, 'cm'),
legend.title = ggplot2::element_text(size=18),
legend.text = ggplot2::element_text(size=16))
catLeg <- cowplot::get_legend(p)
#  create the legend table.
lname <- file.path(directory, fname)
grp <- ceiling(length(table_items)/LegcolN)
l <- (grp * LegcolN) - length(table_items)
table_items <- c(table_items, rep("", l))
v <- matrix(data = table_items , nrow = grp, ncol = LegcolN)
tt2 <- gridExtra::ttheme_minimal(core=list(fg_params=list(hjust=0, x=0.1)),
rowhead=list(fg_params=list(hjust=0, x=0)),
base_size = 20)
tableLeg <- gridExtra::tableGrob(v, theme = tt2)
# Create the bubble size legend
net <- lapply(x, igraph::graph_from_incidence_matrix, weight = T)
deg <- lapply(net, igraph::centr_degree,  mode = "all")
vals <- vector(mode = 'list', length = length(deg))
for (i in 1:length(deg)){
vals[[i]] <- deg[[i]][['res']]
}
interaction_no <- Reduce(c,vals)
breaks <- (max(interaction_no) - min(interaction_no)) / 4
Intervals <- c(min(interaction_no), round(breaks * 1),
round(breaks * 2), round(breaks * 3), max(interaction_no)
)
vals_size <- 2.5 * sqrt(Intervals)
size_legend <- data.frame('Interactions' = Intervals,  'Area' = vals_size)
# prepare the figure
p <- ggplot2::ggplot(size_legend, ggplot2::aes(Interactions, Area, size = Area)) +
ggplot2::geom_point() +
ggplot2::theme(legend.key =
ggplot2::element_rect(fill = "white"),
legend.title.align = 0.5,
legend.key.size = unit(1, 'cm'),
legend.key.height = unit(2, 'cm'),
legend.key.width = unit(2, 'cm'),
legend.title = ggplot2::element_text(size=16),
legend.text = ggplot2::element_text(size=14)) +
ggplot2::labs(size = 'No. of Interacting\nspecies')
sizeLeg <- cowplot::get_legend(p)
# now combine the three legends.
grobBY <- list(tableLeg, sizeLeg, catLeg)
lays <- rbind(
c(1,1,1,1,1, 2),
c(1,1,1,1,1, 2),
c(1,1,1,1,1, 2),
c(1,1,1,1,1, 3),
c(1,1,1,1,1, 3)
)
bucket <- gridExtra::grid.arrange(grobs = grobBY, layout_matrix = lays)
png(lname,
width = 1984, height = dims$H, units = "px", pointsize = 12)
invisible(grid::grid.draw(bucket))
invisible(dev.off())
message(paste0("'", fname,
"' has been rendered as a legend and saved to:\n ",
file.path(directory, fname)))
}
tableLegend2(x = resin, node_clrs = c("#CEAB07", "deeppink2"), ntwrks_page = 9,
colN = 3, LcolN = 1, legend_items = c("Bombus", "Plant"),
table_items = arranged_plants, fill_col = 'black',
LegcolN = 8, y.space = c(1, 1.35, 1.25, 2.25, 1.95))
netPage2 <- function(directory, col_var, row_var, fname, sep_char, mainT, Tlegend_fname) {
if(missing(directory)) { directory <- 'NetworkGraphs' }
if(missing(fname)) {fname <- 'mosaiced_Nets.pdf'}
if(missing(sep_char))  {sep_char <- ''}
if(missing(mainT))  {mainT <- 'Bill walton thinks u forgot a title'}
if(missing(Tlegend_fname)) {Tlegend_fname <- 'TableLegend.png'}
rowOrder <- matrix( # this sets up a matrix to have rows groups in order
data = rep(row_var, each = length(col_var)),
ncol = length(col_var), byrow = T)
colOrder <- matrix( # this sets up a matrix to have column groups in order
data = rep(col_var, each = length(col_var)),
ncol = length(col_var), byrow = F)
image_orders <- matrix(paste0(colOrder, sep_char, rowOrder, '.png'),
ncol = length(col_var))
image_orders <- as.vector(t(image_orders))
image_orders <- file.path(directory, image_orders)
images = lapply(image_orders, png::readPNG)
grob_images = lapply(images, grid::rasterGrob)
nPlots <- (length(col_var) * length(row_var))
colN <- length(col_var)
rowN <- nPlots / length(col_var)
# define the layout
layout <- matrix(nrow = rowN, ncol = colN, byrow = T,
data = c(rep(1:(rowN -1), each = colN),
rowN:((rowN-1) + colN) )
)
layout <- rbind(layout, rep((max(layout) + 1), nrow(layout)))
# Recover the top grobs!!
top_grobs <- split(grob_images[1:(length(grob_images) - rowN)],
ceiling(seq_along(grob_images[1:(length(grob_images) -
rowN)]) / rowN))
names(top_grobs) <- paste0('t', seq(1:length(top_grobs)))
# title up the real top grob
t1 <- gridExtra::arrangeGrob(grobs = top_grobs$t1, ncol = colN,
padding = unit(0.0, "line"),
left = row_var[1], top = mainT)
# this will get all of the subsequent top grobs !!!!!!!!
top_grobs <- mapply(gridExtra::arrangeGrob,
grobs = top_grobs[2:length(top_grobs)], ncol = colN,
left = row_var[2:(length(row_var)-1)],
padding = unit(0.0, "line"))
list2env(top_grobs,env = environment())
# this recovers the bottom grobs
L <- length(grob_images)
range <- ((L - rowN) + 1 ): L
bottom_grobs <- split(grob_images[((L - rowN) + 1 ): L],
seq_along(range) / 1)
names(bottom_grobs) <- paste0('b', seq(1:length(bottom_grobs)))
b1 <- gridExtra::arrangeGrob(grobs = bottom_grobs$b1, bottom = col_var[1],
left = row_var[length(row_var)],
padding = unit(0.0, "line"))
bottoms <- mapply(gridExtra::arrangeGrob,
grobs = bottom_grobs[2:length(bottom_grobs)],
bottom = col_var[2:(length(col_var))],
padding = unit(0.0, "line"))
list2env(bottoms, env = environment())
# ensure the grobs are in the correct order for the mosaic.
g2p <- mget(ls(pattern = '[t|b][1-9]{1}'))
groborder <- c(paste0('t', seq(1:9)), paste0('b', seq(1:9)))
ord2grab <- match(groborder, names(g2p)) |> na.omit()
g2p <- g2p[ord2grab]
# load and place the legend onto the grobs2plot
legend <- grid::rasterGrob(png::readPNG(file.path(directory, Tlegend_fname)))
legend <- gridExtra::arrangeGrob(legend, nrow = 1)
g2p <- c(g2p, leg = list(legend))
# place on the page and print.
ml <- gridExtra::marrangeGrob(grobs = g2p,
layout_matrix = layout, top = '')
pdf(file = file.path(directory, fname), paper = 'a4')
print(ml)
invisible(dev.off())
message(paste0("'", fname,
"' has been rendered as a pdf and saved to:\n ",
file.path(directory, fname)))
return(g2p)
}
netPage2(col_var = c('Kraken', 'Bracken', 'BLAST'),
mainT = 'Comparision of Foraging Patterns from Three Sequence Alignment Algorithms',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
#' @param y.space a numeric vector of 'distances' for the legend elements
#' @param filename defaults to 'SizeLegend'
#' @param ntwrks_page the number of networks you plan on placing on each page
#' @param LcolN number of columns to split legend across
#' @param LegcolN number of columns in the table
#' @param colN number of columns for the nets on the page
#' @seealso
#' @example category_legend_drawer(node_clrs
#' = c("#CEAB07", "deeppink2"), LcolN = 1,
#'  legend_items = c("Bombus", "Plant"), ntwrks_page = 9, colN =3)
tableLegend2 <- function(x, table_items, directory, fname, legend_items, node_clrs,
fill_col, y.space, ntwrks_page, colN, LcolN, LegcolN){
if(missing(directory)) { directory <- 'NetworkGraphs' }
if(missing(fname)) {fname <- 'TableLegend.png'}
if(missing(fill_col)){fill_col <- 'white'}
if(missing(y.space)){y.space <- seq(from = 1, to = 2, length.out = 5)}
dims <- graph_dims(ntwrks_page, col = colN)
# create the categorical legend.
d <- data.frame(Group = c('Bombus', 'Plant'),
Dummy = c(1,1), Dummy2 = c(1,1))
v <- c("#CEAB07", "deeppink2")
names(v) <- c('Bombus', 'Plant')
p <- ggplot2::ggplot(d, ggplot2::aes(x= Dummy, y=Dummy2, color = Group)) +
ggplot2::geom_point() +
ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size=12))) +
ggplot2::scale_fill_manual(v) +
ggplot2::labs(color = 'Major Interacting\nGroups ') +
ggplot2::theme(legend.key = ggplot2::element_rect(fill = "white"),
legend.title.align = 0.5,
legend.key.size = unit(2.5, 'cm'),
legend.key.height = unit(3, 'cm'),
legend.key.width = unit(3, 'cm'),
legend.title = ggplot2::element_text(size = 24),
legend.text = ggplot2::element_text(size = 20))
catLeg <- cowplot::get_legend(p)
#  create the legend table.
lname <- file.path(directory, fname)
grp <- ceiling(length(table_items)/LegcolN)
l <- (grp * LegcolN) - length(table_items)
table_items <- c(table_items, rep("", l))
v <- matrix(data = table_items , nrow = grp, ncol = LegcolN)
tt2 <- gridExtra::ttheme_minimal(core=list(fg_params=list(hjust=0, x=0.1)),
rowhead=list(fg_params=list(hjust=0, x=0)),
base_size = 20)
tableLeg <- gridExtra::tableGrob(v, theme = tt2)
# Create the bubble size legend
net <- lapply(x, igraph::graph_from_incidence_matrix, weight = T)
deg <- lapply(net, igraph::centr_degree,  mode = "all")
vals <- vector(mode = 'list', length = length(deg))
for (i in 1:length(deg)){
vals[[i]] <- deg[[i]][['res']]
}
interaction_no <- Reduce(c,vals)
breaks <- (max(interaction_no) - min(interaction_no)) / 4
Intervals <- c(min(interaction_no), round(breaks * 1),
round(breaks * 2), round(breaks * 3), max(interaction_no)
)
vals_size <- 2.5 * sqrt(Intervals)
size_legend <- data.frame('Interactions' = Intervals,  'Area' = vals_size)
# prepare the figure
p <- ggplot2::ggplot(size_legend, ggplot2::aes(Interactions, Area, size = Area)) +
ggplot2::geom_point() +
ggplot2::theme(legend.key =
ggplot2::element_rect(fill = "white"),
legend.title.align = 0.5,
legend.key.size = unit(1, 'cm'),
legend.key.height = unit(2, 'cm'),
legend.key.width = unit(2, 'cm'),
legend.title = ggplot2::element_text(size = 24),
legend.text = ggplot2::element_text(size = 20)) +
ggplot2::labs(size = 'No. of Interacting\nspecies')
sizeLeg <- cowplot::get_legend(p)
# now combine the three legends.
grobBY <- list(tableLeg, sizeLeg, catLeg)
lays <- rbind(
c(1,1,1,1,1, 2),
c(1,1,1,1,1, 2),
c(1,1,1,1,1, 2),
c(1,1,1,1,1, 3),
c(1,1,1,1,1, 3)
)
bucket <- gridExtra::grid.arrange(grobs = grobBY, layout_matrix = lays)
png(lname,
width = 1984, height = dims$H, units = "px", pointsize = 12)
invisible(grid::grid.draw(bucket))
invisible(dev.off())
message(paste0("'", fname,
"' has been rendered as a legend and saved to:\n ",
file.path(directory, fname)))
}
tableLegend2(x = resin, node_clrs = c("#CEAB07", "deeppink2"), ntwrks_page = 9,
colN = 3, LcolN = 1, legend_items = c("Bombus", "Plant"),
table_items = arranged_plants, fill_col = 'black',
LegcolN = 8, y.space = c(1, 1.35, 1.25, 2.25, 1.95))
netPage2(col_var = c('Kraken', 'Bracken', 'BLAST'),
mainT = 'Comparision of Foraging Patterns from Three Sequence Alignment Algorithms',
row_var = c('Early', 'Mid', 'Late'), sep = '.')
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
gapminder
library(gapminder)
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
data("gapminder")
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) #%>%
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) #+
dev.off()
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) #+
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
gapminder %>%
group_by(continent, year) %>%
mutate(
gdpPercapweighted = mean(x = gdpPercap, w = pop),
pop = sum(as.numeric(pop))) %>%
ggplot( aes(year, gdpPercap)) +
geom_point(aes(color = factor(continent),
size = pop/100000)) +
scale_size_continuous(range = c(1,3)) +
geom_line(aes(color = factor(continent), group = country)) +
# nice simple theme
theme_bw() +
# create the 5 continent facet
facet_wrap(~continent, ncol = 5 ) +
# we add the means black points and lines here
geom_point(aes(year, gdpPercapweighted,
size=pop/100000)) +
geom_line(aes(year, gdpPercapweighted))  +
# update all of the labels here.
labs(x="Year",
y ="GDP per capita",
color="Continent",
size="Population (100k)") #good
